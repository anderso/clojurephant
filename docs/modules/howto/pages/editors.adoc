= Editor Integrations

For a Clojure project, the main detail to get working with any editor is the REPL connection, so that's what we'll focus on in this document.

== CIDER (Emacs)

link:https://github.com/clojure-emacs/cider[CIDER] (The Clojure Interactive Development Environment for Emacs that Rocks) functionality is largely build-tool-agnostic except for the startup (a.k.a "jack-in") process to start and connect to nREPL. In recent versions, this works with Gradle the same as it does for other build tools.

Once you're jacked-in or connected, see https://docs.cider.mx[CIDER's documentation] for usage information.

NOTE: `cider-javadoc` does not require `enrich-classpath` to work with Gradle. Clojurephant will automatically add sources/javadoc JARs of your dependencies to the REPL classpath.

=== (Easiest) Jack-in (w/ dependencies)

[TIP]
====
For CIDER's dependency injection to work to work, you need at least:

Clojurephant:: 0.7.0-alpha.6
CIDER:: v20220731.522 from MELPA (or a release newer than v1.4.1).
====

As long as your Gradle build is using either or both of the xref:reference:plugins/clojure.adoc[] or xref:reference:plugins/clojurescript.adoc[] plugins, CIDER will handle the rest.

. Open Emacs
. Visit a Clojure file in your project
. Run `M-x cider-jack-in-clj`

CIDER will automatically inject the needed nREPL version and middleware, start the nREPL server, and connect to it.

=== (Manual) Add dependencies to your build

If you're someone who `(setq cider-inject-dependencies-at-jack-in nil)`, then here are the needed changes to manually configure your project for use with CIDER.

==== Build Config

.build.gradle
[source, groovy, subs="attributes"]
----
dependencies {
  devImplementation 'cider:cider-nrepl:{cider-nrepl-version}'
}

clojureRepl {
  middleware = ['cider.nrepl/cider-middleware']
}
----

==== Jack-in (w/o dependencies)

. Open Emacs
. Visit a Clojure file in your project
. Run `M-x cider-jack-in-clj`

==== (or) Connect to already running REPL

Start your nREPL server.

[source, shell]
----
$ ./gradlew clojureRepl
----

Optionally, omit the middleware from the `build.gradle` and include it on the commandline:

[source, shell]
----
$ ./gradlew clojureRepl --middleware=cider.nrepl/cider-middleware
----

Then `M-x cider-connect`. CIDER should pick up the port via the `.nrepl-port` file.

== Calva (VS Code)

NOTE: We're link:https://github.com/BetterThanTomorrow/calva/pull/1815[working on] adding an out-of-box project type for Gradle to Calva. That will simplify the usage described here.

Once you're jacked-in or connected, see link:https://calva.io/[Calva's documentation] for usage information.

=== (Manual) Add dependencies to your build

If you want to control the dependencies yourself, here are the needed changes to manually configure your project for use with Calva.

==== Build Config

.build.gradle
[source, groovy, subs="attributes"]
----
dependencies {
  devImplementation 'cider:cider-nrepl:{cider-nrepl-version}'
}

clojureRepl {
  middleware = ['cider.nrepl/cider-middleware']
}
----

==== Connect to already running REPL (Custom)

Create a custom Calva connect sequence in your user or workspace `settings.json`.

.settings.json
[source, json]
----
{
  "calva.replConnectSequences": [
    {
      "name": "Custom Gradle",
      "projectType": "generic",
      "nReplPortFile": [
        ".nrepl-port"
      ],
      "cljsType": "none"
    }
  ]
}
----

Start your nREPL server.

[source, shell]
----
$ ./gradlew clojureRepl
----

Optionally, omit the middleware from the `build.gradle` and include it on the commandline:

[source, shell]
----
$ ./gradlew clojureRepl --middleware=cider.nrepl/cider-middleware
----

Then `Calva: Connect to a Runnig REPL Server in the Project` (`CTRL+ALT+C CTRL+ALT+C`). Choose the `Custom Gradle` project type. Calva will pick up the port automatically.


==== (or) Connect to already running REPL (Generic)

Start your nREPL server.

[source, shell]
----
$ ./gradlew clojureRepl
----

Optionally, omit the middleware from the `build.gradle` and include it on the commandline:

[source, shell]
----
$ ./gradlew clojureRepl --middleware=cider.nrepl/cider-middleware
----

Then `Calva: Connect to a Runnig REPL Server in the Project` (`CTRL+ALT+C CTRL+ALT+C`). Choose the `Generic` project type and input the REPL port from your Gradle output.

== Cursive (Intellij)

Intellij has its own Gradle support, so that will cover getting things imported and the ability to run ad-hoc Gradle tasks.

NOTE: As of 2022-08-02, Cursive doesn't have direct Gradle support, but it is generally compatible once the project is imported.

Once you're connected to the REPL, see link:https://cursive-ide.com/userguide/[Cursive's documentation] for usage information.

=== Start your nREPL Server

Kick off the REPL task from the shell.

[source, shell]
----
$ ./gradlew clojureRepl
----

This will create the standard `.nrepl-port` file in your project root once the nREPL server is running.

=== Connect to Remote REPL

Cursive refers to this as a "remote" REPL, just meaning that it didn't start the REPL for you.

. In _Run_ -> _Edit Configurations_
. Click the _+_ to make a new configuration, choose _Clojure REPL_ -> _Remote REPL_
. Fill in the _Name_, as desired (we'll use `Gradle REPL`)
. Choose _nREPL_ as the connection type
. Choose _Use port from nREPL file_
.. Choose your project's `*.dev` module as the _Context Module_
.. Specify custom port file as `../../.nrepl-port` (presuming you use the standard `src/dev/clojure` project layout)
. Click _OK_

Now start your `Gradle REPL` run configuration.

Success! Now you can continue using Cursive with your active REPL.
